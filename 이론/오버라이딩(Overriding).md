## 오버라이딩(Overriding)

### 1. 오버라이딩 이란?

★ 조상 클래스로부터 상속받은 메소드의 내용을 변경하는 것을 오버라이딩이라고 한다.

(상속 받은 메소드를 그대로 사용하기도 하지만, 자손 클래스 자신에 맞게 변경해야하는 경우가 많다. 이럴 때(?) 조상의 메소드를 오버라이딩한다.)

ex)

class Point{
	int x;
	int y;
	String getLocation() {
		return "x :" + x + ", y :" + y;
	}
}

class Point3D extends Point {
	int z;
	String getLocation(){
		return "x :" + x + ", y :" + y + ", z :" + z; 	
	}
}

 Point 클래스의 getLocation은 한 점의 x,y 좌표를 문자열로 반환하도록 작성되었다.

이 두 클래스는 서로 상속관계에 있으므로 Point3D 클래스는 Point클래스로부터 getLocation()을 상속받지만, Point3D클래스는 3차원 좌표계의 한 점을 표현하기 위한 것이므로 조상인 Point클래스로부터 상속받은 getLocation()은 Point3D클래스에 맞지 않는다.

그래서 이 메소드를 Point3D클래스 자신에 맞게 z축의 좌표값도 포함하여 반환하도록 오버라이딩 하였다.

<br>

### 2. 오버라이딩의 조건

자손클래스에서 오버라이딩하는 메소드는 조상클래스의 메소드와

\- 이름이 같아야 한다.

\- 매개변수가 같아야 한다.

\- 반환타입이 같아야 한다.

즉, 선언부가 서로 일치해야 한다.

다만 접근 제어자(access modifier)와 예외(exception)는 제한된 조건 하에서만 다르게 변경할 수 있다.

<참고> - JDK1.5부터 '공변 반환타입(convariant return type)'이 추가되어, 반환타입을 자손클래스의 타입으로 변경하는 것은 가능하도록 조건이 완화되었다.

1. 접근 제어자는 조상클래스의 메소드보다 좁은 범위로 변경할 수 있다.

   만일 조상 클래스에 정의된 메소드의 접근 제어자가 protected라면, 이를 오버라이딩하는 자손 클래스의 매소드는 접근제어자가 protected나 public이어야 한다.

   대부분의 경우 같은 범위의 접근제어자를 사용한다. 

   ( 접근 제어자의 접근범위를 넓은 것에서 좁은 것 순으로 나열하면 public, protected, (default), private 이다. )

2. 조상 클래스의 메소드보다 많은 수의 예외를 선언할 수 있다.

3. 인스턴스메소드를 static메소드로 또는 그 반대로 변경할 수 없다.



### 3. super

\- super는 자손 클래스에서 조상 클래스로부터 상속받은 멤버를 참조하는데 사용되는 참조변수이다.

(멤버변수와 지역벼수의 이름이 같을 때 this를 붙여서 구별했듯이 상속받은 멤버와 자신의 이름이 같을 때는 super를 붙여서 구별할 수 있다.)

\- 조상 클래스로부터 상속받은 멤버도 자손 클래스 자신의 멤버이므로 super 대신 this를 사용할 수 있다.

그래도 조상 클래스의 멤버와 자손클래스의 멤버가 중복 정의되어 서로 구별해야하는 경우에만 super를 사용하는 것이 좋다.

\- 조상의 멤버와 자신의 멤버를 구별하는데 사용된다는 점을 제외하고는 super와 this는 근본적으로 같다.

\- 모든 인스턴스메소드에서는 자신이 속한 인스턴스의 주소가 지역변수로 저장되는데, 이것이 참조변수인 this와 super의 값이 된다.

<br>

------------------------------코드예시------------------------------

public class SuperTest2 {
	public static void main(String args[]) {
		Child c = new Child();
		c.method(15);
	}
}
class Parent {
	int x=10;
}

class Child extends Parent {
	int x=20;

​	void method(int x) {
​		System.out.println("x=" + x);
​		System.out.println("this.x=" + this.x);
​		System.out.println("super.x="+ super.x);
​	}
}

--------------------------다음 코드의 결과값은--------------------------

x=15
this.x=20
super.x=10

이다.

<br>

### 4. super() - 조상 클래스의 생성자

this()와 마찬가지로 super() 역시 생성자이다.

this()는 같은 클래스의 다른 생성자를 호출하는 데 사용되지만, super()는 조상 클래스의 생성자를 호출하는데 사용된다.

자손 클래스의 인스턴스를 생성하면, 자손의 멤버와 조상의 멤버가 모두 합쳐진 하나의 인스턴스가 생성된다. 그래서 자손 클래스의 인스턴스가 조상 클래스의 멤버들을 사용할 수 있는 것이다.

\- Object클래스를 제외한 모든 클래스의 생성자 첫 줄에 생성자, this() 또는 super()를 호출해야 한다. 그렇지 않으면 컴파일러가 자동적으로 'super();' 를 생성자의 첫 줄에 삽입한다.



